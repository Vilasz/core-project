// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

enum UserRole {
  STUDENT
  TEACHER
}

enum BookingStatus {
  PENDING
  CONFIRMED
  COMPLETED
  CANCELLED
}

enum PaymentStatus {
  PENDING
  COMPLETED
  FAILED
  REFUNDED
}

enum Modality {
  YOGA
  MEDITATION
  PILATES
  FITNESS
  DANCE
  OTHER
}

model User {
  id             String    @id @default(cuid())
  name           String?
  email          String    @unique
  image          String?
  role           UserRole  @default(STUDENT)
  phone          String?
  hashedPassword String?
  emailVerified  DateTime?
  createdAt      DateTime  @default(now())
  updatedAt      DateTime  @updatedAt

  // Relations
  teacherProfile      TeacherProfile?
  // [CORREÇÃO] O nome da relação "StudentBookings" agora corresponde ao do modelo Booking
  bookingsAsStudent   Booking[]       @relation("StudentBookings")
  bookingsAsTeacher   Booking[]       @relation("TeacherBookings")
  reviewsGiven        Review[]
  reviewsReceived     Review[]        @relation("TeacherReviews")
  postedTimes         PostedTime[]
  classRequests       ClassRequest[]

  @@map("users")
}

model TeacherProfile {
  id           String   @id @default(cuid())
  userId       String   @unique
  bio          String?
  specialties  String[]
  hourlyRate   Float
  rating       Float    @default(0)
  phone        String?
  totalReviews Int      @default(0)
  isAvailable  Boolean  @default(true)
  availability Json?
  createdAt    DateTime @default(now())
  updatedAt    DateTime @updatedAt

  // Relations
  user     User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  // [CORREÇÃO] O nome da relação "ProfileBookings" agora corresponde ao do modelo Booking
  bookings Booking[] @relation("ProfileBookings")

  @@map("teacher_profiles")
}

model Booking {
  id              String        @id @default(cuid())
  studentId       String
  teacherId       String // [CORREÇÃO] Usaremos este campo para as duas relações abaixo
  date            DateTime
  duration        Int
  status          BookingStatus @default(PENDING)
  price           Float
  stripeSessionId String?
  notes           String?
  createdAt       DateTime      @default(now())
  updatedAt       DateTime      @updatedAt

  // Relations
  // [CORREÇÃO] O nome "StudentBookings" agora bate com o do modelo User
  student        User           @relation("StudentBookings", fields: [studentId], references: [id])
  // [CORREÇÃO] Relação com o User (teacher) com um nome de constraint único
  teacher        User           @relation("TeacherBookings", fields: [teacherId], references: [id], map: "fk_booking_teacher")
  // [CORREÇÃO] Relação com TeacherProfile, usando o mesmo teacherId, mas com nome e constraint únicos
  teacherProfile TeacherProfile @relation("ProfileBookings", fields: [teacherId], references: [userId], map: "fk_booking_teacher_profile")
  reviews        Review[]
  payments       Payment[]

  @@map("bookings")
}

model Review {
  id        String   @id @default(cuid())
  bookingId String   @unique
  studentId String
  teacherId String
  rating    Int
  comment   String?
  createdAt DateTime @default(now())

  // Relations
  booking Booking @relation(fields: [bookingId], references: [id], onDelete: Cascade)
  student User    @relation(fields: [studentId], references: [id])
  teacher User    @relation("TeacherReviews", fields: [teacherId], references: [id])

  @@map("reviews")
}

model Payment {
  id              String        @id @default(cuid())
  bookingId       String
  amount          Float
  status          PaymentStatus @default(PENDING)
  stripePaymentId String?
  stripeSessionId String?
  createdAt       DateTime      @default(now())
  updatedAt       DateTime      @updatedAt

  // Relations
  booking Booking @relation(fields: [bookingId], references: [id], onDelete: Cascade)

  @@map("payments")
}

model PostedTime {
  id           String    @id @default(cuid())
  teacherId    String
  date         DateTime
  startTime   String
  endTime      String
  modality     Modality
  price        Float
  isAvailable  Boolean   @default(true)
  description  String?
  contactPhone String?
  contactEmail String?
  createdAt    DateTime  @default(now())
  updatedAt    DateTime  @updatedAt

  // Relations
  user User @relation(fields: [teacherId], references: [id], onDelete: Cascade)

  @@map("posted_times")
}

model ClassRequest {
  id           String    @id @default(cuid())
  studentId    String
  modality     Modality
  preferredDate DateTime?
  preferredTime String?
  duration     Int
  maxPrice     Float?
  description  String?
  contactPhone String?
  contactEmail String?
  isActive     Boolean   @default(true)
  createdAt    DateTime  @default(now())
  updatedAt    DateTime  @updatedAt

  // Relations
  user User @relation(fields: [studentId], references: [id], onDelete: Cascade)

  @@map("class_requests")
}
